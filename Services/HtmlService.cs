using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace OBS_Twitch_Challange_BoT.Services
{
    public class HtmlService
    {

        readonly static string fileDirectory = $"{Directory.GetCurrentDirectory()}/Html/";

        public void GenerateHTMLFile(string htmlFile)
        {

            GenerateJavaScriptFile("main.js");
            GenerateCSSFile("style.css");

            //check if file exists, if not then generate file

            FileExists(htmlFile);

            //write content into file

            string htmlContent = @"
            <!DOCTYPE html>
<html lang=""en"">

<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>Challange</title>
    <link rel=""stylesheet"" href=""style.css"">
</head>

<body>
    <div class=""container"">
        <div class=""title"">
            <h1>Shoot Target To find out your challenge</h1>

        </div>
        <div id=""targets-container""></div>
        <div id=""challenge-result"" class=""hidden"">
            <div>
                <h2 id=""selected-challenge""></h2>
            </div>
            <h3 id=""selected-challenge-description"">
            </h3>
        </div>
    </div>

    <script src=""main.js""></script>
</body>

</html>

";
            string filePath = Path.Combine(fileDirectory, htmlFile);
            try
            {
                using (StreamWriter writer = new StreamWriter(filePath))
                {
                    writer.WriteLine(htmlContent);

                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"An Error occured while writing to the file :{ex.Message}");
            }
        }

        public void GenerateJavaScriptFile(string jsFileName)
        {

            //check if file exists, if not then generate file
            FileExists(jsFileName);

            string jsContent = @"
const challengeCount = 9;
const OBS_ADDRESS = ""192.168.0.12"";
const OBS_PORT = 4455;
const OBS_PASSWORD = ""CLx786mDzBfysROx"";

const TITLE_TEXT_SOURCE = ""Challange Title"";
const DESCRIPTION_TEXT_SOURCE = ""Challange Desc"";
//sound effect when choosing targets

// List of challenges
const challenges = [
  {
    title: ""X Kills in a Game"",
    desc: ""Get a specific number of kills (e.g., 10, 15, 20). Adjust based on your skill level"",
  },
  {
    title: ""One-Gun Kill"",
    desc: ""Get all your kills using only one type of weapon (e.g., pistols, snipers, or shotguns). "",
  },
  {
    title: ""No Reload"",
    desc: ""You're not allowed to reload during combat. Must switch to another weapon or melee."",
  },
  {
    title: ""Revenge Hunter"",
    desc: ""Hunt down and eliminate the player who killed you if you return via the Gulag."",
  },
  {
    title: ""Execution-Only"",
    desc: "" Get at least one execution/finishing move in the game."",
  },
  {
    title: ""Headshot Only"",
    desc: ""Every kill must be a headshot. Any non-headshot kill doesn't count."",
  },
  {
    title: ""Random Loadout"",
    desc: "" Use a randomized loadout generated by viewers or a Warzone loadout generator tool"",
  },
  {
    title: ""Ground Loot Only"",
    desc: "" You can only use weapons and gear found on the ground - no loadout drops."",
  },
  {
    title: ""No Attachments"",
    desc: "" Use guns without any attachments."",
  },
  {
    title: ""Throwables Only"",
    desc: "" All kills must be with grenades, Molotovs, throwing knives, or C4."",
  },
  {
    title: ""Melee Only"",
    desc: "" Get all your kills with melee weapons or bare fists."",
  },
  {
    title: ""No Buy Station"",
    desc: ""Survive without using a buy station (no UAVs, loadout purchases, or revives). "",
  },
  {
    title: ""Pacifist"",
    desc: "" Try to survive as long as possible without killing anyone."",
  },
  {
    title: ""Circle Hugger"",
    desc: "" Stick to the edge of the safe zone the entire game and avoid the center. "",
  },
  {
    title: ""Gulag-Free Run"",
    desc: ""If you die, you must quit the match - no Gulag allowed. "",
  },
  {
    title: ""Sniper's Nest"",
    desc: "" Stay on rooftops or high ground for the entire game. "",
  },
  {
    title: ""No Armor Plates"",
    desc: "" Play the game without equipping any armor plates. "",
  },
  {
    title: ""No Sprinting"",
    desc: "" You're not allowed to sprint during the game. "",
  },
  {
    title: ""Chat-Selected Drop"",
    desc: "" Let the chat choose where you drop. "",
  },
  {
    title: ""Chat-Driven Contracts"",
    desc: "" Let viewers decide which contract you pick next (bounty, scavenger, etc.)."",
  },
  {
    title: ""Kill Count Prediction"",
    desc: "" Viewers guess how many kills you'll get, and you try to beat their predictions. "",
  },
  {
    title: ""No Map"",
    desc: "" Play without looking at the map or minimap. "",
  },
];

////// DO NOT CHANGE ANYTHING BELOW
class OBSWebSocket {
  constructor(config) {
    this.address = config.address || ""127.0.0.1"";
    this.port = config.port || 4455;
    this.password = config.password || """";
    this.socket = null;
    this.isConnected = false;
  }

  // Connect to OBS WebSocket server
  connect() {
    this.socket = new WebSocket(`ws://${this.address}:${this.port}`);

    this.socket.onopen = (event) => {
      console.log(""Connected to OBS WebSocket server"");
      this.isConnected = true;
    };

    this.socket.onclose = (event) => {
      console.log(""Disconnected from OBS WebSocket server"");
      console.log(""Reason:"", event.reason);
      console.log(""Code:"", event.code);
      this.isConnected = false;
    };

    this.socket.onerror = (error) => {
      console.error(""WebSocket error:"", error);
    };

    this.socket.onmessage = async (event) => {
      console.log(""Received message:"", event.data);

      const response = JSON.parse(event.data);

      // If authentication is required, send a response
      if (response.d.authentication && response.op === 0) {
        const salt = response.d.authentication.salt;
        const challenge = response.d.authentication.challenge;
        const authResponseHash = await this.authenticate(salt, challenge);

        const payload = {
          op: 1,
          d: {
            rpcVersion: 1,
            authentication: authResponseHash,
          },
        };

        this.socket.send(JSON.stringify(payload));
      }
    };
  }

  // Generate SHA-256 hash of the given input
  async sha256Hash(inputText) {
    const utf8 = new TextEncoder().encode(inputText);
    const hashBuffer = await crypto.subtle.digest(""SHA-256"", utf8);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const base64Hash = btoa(String.fromCharCode(...hashArray));
    return base64Hash;
  }

  // Perform the authentication
  async authenticate(salt, challenge) {
    try {
      const secret = await this.sha256Hash(this.password + salt);
      const authResponseHash = await this.sha256Hash(secret + challenge);
      return authResponseHash;
    } catch (error) {
      console.error(""Authentication failed:"", error);
    }
  }

  // Send a message to OBS
  sendMessage(opcode, data) {
    if (this.isConnected && this.socket) {
      const message = {
        op: opcode,
        d: data,
      };
      this.socket.send(JSON.stringify(message));
    } else {
      console.error(""Not connected to OBS WebSocket."");
    }
  }

  // Change the text of a Text GDI source
  async GetSettings(sourceName) {
    if (!this.isConnected || !this.socket) {
      console.error(""Not connected to OBS WebSocket."");
      return;
    }

    // Generate a unique requestId
    const requestId = Date.now().toString();

    // Construct the message to set the text
    const message = {
      op: 6, // SetText operation code
      d: {
        requestType: ""GetInputSettings"", // The correct requestType
        requestId: requestId,
        requestData: {
          inputName: sourceName,
        },
      },
    };

    // Send the message to OBS WebSocket
    this.socket.send(JSON.stringify(message));
    //console.log(`Sent SetText to source ${sourceName}""`);
  }

  // Change the text of a Text GDI source
  async changeText(sourceName, newText) {
    if (!this.isConnected || !this.socket) {
      console.error(""Not connected to OBS WebSocket."");
      return;
    }

    // Generate a unique requestId
    const requestId = Date.now().toString();

    // Construct the message to set the text
    const message = {
      op: 6, // SetText operation code
      d: {
        requestType: ""SetInputSettings"", // The correct requestType
        requestId: requestId,
        requestData: {
          inputName: sourceName,
          inputSettings: {
            text: newText, // New text to update
          },
        },
      },
    };

    // Send the message to OBS WebSocket
    this.socket.send(JSON.stringify(message));
    console.log(
      `Sent SetText to source ${sourceName} with new text: ""${newText}""`
    );
  }
  // Disconnect from the WebSocket
  disconnect() {
    if (this.socket) {
      this.socket.close();
    }
  }
}

// Example usage:
const obsConfig = {
  address: OBS_ADDRESS,
  port: OBS_PORT,
  password: OBS_PASSWORD,
};

const obsWebSocket = new OBSWebSocket(obsConfig);
obsWebSocket.connect();

//select challenge count from available challenges

var selectedChallenges = [];

while (selectedChallenges.length < challengeCount) {
  var chosenChallenge =
    challenges[Math.floor(Math.random() * challenges.length)];
  if (!selectedChallenges.includes(chosenChallenge)) {
    selectedChallenges.push(chosenChallenge);
  }
}

// Create targets dynamically
const targetsContainer = document.getElementById(""targets-container"");

// Function to create targets
function createTargets() {
  for (let i = 0; i < selectedChallenges.length; i++) {
    const target = document.createElement(""div"");
    target.classList.add(""target"");
    target.setAttribute(""data-index"", i); // Store index in data attribute
    targetsContainer.appendChild(target);
  }
}

// Function to simulate randomly shooting a target
function shootRandomTarget() {
  const targets = document.querySelectorAll("".target"");
  const randomTargetIndex = Math.floor(Math.random() * targets.length);
  const randomTarget = targets[randomTargetIndex];

  //clearing TEXT SOURCES before applying new challange
  obsWebSocket.changeText(TITLE_TEXT_SOURCE, ""Rolling new challenge....."");
  obsWebSocket.changeText(DESCRIPTION_TEXT_SOURCE, """");

  // Add the target-highlight class to simulate the ""selection"" process
  let selectionInProgress = true;
  let counter = 0;
  const highlightInterval = setInterval(() => {
    const randomTargetIndex = Math.floor(Math.random() * targets.length); // Select random target
    const target = targets[randomTargetIndex];

    target.classList.add(""target-highlight""); // Highlight the target

    // Reset previous target highlight after a short time
    setTimeout(() => {
      target.classList.remove(""target-highlight"");
    }, 250);

    counter++;
    if (counter >= 10) {
      // Run for 10 iterations before stopping
      clearInterval(highlightInterval); // Stop the random highlight process
      selectionInProgress = false;
      target.classList.remove(""target-highlight"");
      // After the selection process is finished, shoot the final target
      randomTarget.classList.add(""target-shot""); // Shot effect on the selected target

      // Select a random challenge
      const randomChallenge =
        challenges[Math.floor(Math.random() * challenges.length)];

      // Display the selected challenge
      const challengeResult = document.getElementById(""challenge-result"");
      const selectedChallengeElement =
        document.getElementById(""selected-challenge"");
      const selectedChallengeDescElement = document.getElementById(
        ""selected-challenge-description""
      );
      const textDisplayInterval = setInterval(() => {
        selectedChallengeElement.textContent = `${randomChallenge.title} challenge!`;
        selectedChallengeDescElement.textContent = `${randomChallenge.desc}`;
        activeChallenge = `${randomChallenge.title} - ${randomChallenge.desc}`;
        obsWebSocket.changeText(TITLE_TEXT_SOURCE, randomChallenge.title);
        obsWebSocket.changeText(DESCRIPTION_TEXT_SOURCE, randomChallenge.desc);
        clearInterval(textDisplayInterval);
      }, 500);

      challengeResult.classList.remove(""hidden"");
    }
  }, 500); // Change target every 500ms
}

// Initialize the game by creating targets and automatically shooting a random target
createTargets();
//updateTextSource(OBS_TEXT_SOURCE, activeChallenge);
// Add a delay before starting the target selection process
setTimeout(() => {
  shootRandomTarget();
}, 1500); // 1.5 second delay before the selection process starts



";

            string filePath = Path.Combine(fileDirectory, jsFileName);
            try
            {
                using (StreamWriter writer = new StreamWriter(filePath))
                {
                    writer.WriteLine(jsContent);

                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"An Error occured while writing to the file :{ex.Message}");
            }

        }


        public void GenerateCSSFile(string cssFileName)
        {


            //check if file exists, if not then generate file
            FileExists(cssFileName);

            string cssContent = @"/* General styles */
body {
    font-family: 'Arial', sans-serif;
    display: flex;
    background-color: green;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;

}

.container {
    text-align: center;
    padding: 20px;
}

.title {
    color: red;
}

.title>h1 {
    font-family: cursive;
    font-size: 70px;
    font-weight: bolder;
    animation: colorchange 3s infinite;
}


@keyframes colorchange {
    0% {
        color: red;
    }

    50% {
        color: blue
    }

    100% {
        color: green
    }

}



h1 {
    font-size: 2rem;
}

#targets-container {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 20px;
}

.target {
    width: 80px;
    height: 80px;
    background-color: #fff;
    border-radius: 50%;
    border: 5px solid #333;
    position: relative;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    transition: transform 0.2s ease;
}

.target:hover {
    transform: scale(1.1);
}

.target:active {
    transform: scale(0.9);
}

.target:before,
.target:after {
    content: """";
    position: absolute;
    top: 50%;
    left: 50%;
    width: 50%;
    height: 50%;
    border-radius: 50%;
    background-color: transparent;
    border: 2px solid #333;
    transform: translate(-50%, -50%);
}

.target:before {
    width: 70%;
    height: 70%;
}

.target:after {
    width: 40%;
    height: 40%;
}

.target-shot {
    animation: shotEffect 0.5s forwards;
}

@keyframes shotEffect {
    0% {
        transform: scale(1);
        background-color: #fff;
    }

    50% {
        transform: scale(1.2);
        background-color: #FF6347;
        /* Red color to show shot */
    }

    100% {
        transform: scale(1);
        background-color: #FF6347;
        /* Red color to indicate hit */
    }
}

.target-highlight {
    animation: highlightEffect 0.3s alternate infinite;
}

@keyframes highlightEffect {
    0% {
        transform: scale(1);
        border-color: #3498db;
        box-shadow: 0 0 10px rgba(52, 152, 219, 0.8);
    }

    100% {
        transform: scale(1.2);
        border-color: #e74c3c;
        box-shadow: 0 0 15px rgba(231, 76, 60, 0.8);
    }
}

#challenge-result {
    margin-top: 40px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: red;
}

#selected-challenge {
    font-size: 50px;
}

#selected-challenge-description {
    font-size: 30px;
}

#challenge-result.hidden {
    display: none;
}

#retry-btn {
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#retry-btn:hover {
    background-color: #2980b9;
}";

            string filePath = Path.Combine(fileDirectory, cssFileName);
            try
            {
                using (StreamWriter writer = new StreamWriter(filePath))
                {
                    writer.WriteLine(cssContent);

                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"An Error occured while writing to the file :{ex.Message}");
            }

        }


        private static void FileExists(string fileName)
        {


            var result = File.Exists($"{fileDirectory}{fileName}");

            if (!result)
            {
                File.Create($"{fileDirectory}{fileName}");
            }

        }


    }
}
